\documentclass[11pt,a4paper]{amsart}

\usepackage[margin=1in]{geometry}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage[american]{babel}
\usepackage{microtype}
\usepackage{amsmath,amssymb,amsthm,mathtools}
\usepackage[hidelinks]{hyperref}
\usepackage{cleveref}

% ============================================================================
% Theorem environments
% ============================================================================
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

% ============================================================================
% Notation
% ============================================================================
\newcommand{\NN}{\mathbb{N}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\Nbh}{N}
\newcommand{\NbhC}[1]{N[#1]}
\newcommand{\Np}{N^{+}}
\newcommand{\id}{\mathrm{id}}
\newcommand{\Dom}{\mathrm{Dom}}
\DeclareMathOperator{\arb}{arb}
\DeclareMathOperator{\idsum}{idsum}
\newcommand{\proc}[1]{\textup{\mdseries\textsc{#1}}}

\title[Dynamic dominating set in bounded-degeneracy graphs]{A fully dynamic data structure for parameterized\\ dominating set in graphs of bounded degeneracy}
\author{Bart{\l}omiej Bosek}
\thanks{This work is a~part of project BOBR that has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreement No. 948057).}
\address{Institute of Theoretical Computer Science, Jagiellonian University in Krak\'ow\\Institute of Informatics, University of Warsaw, Poland}
\email{bartlomiej.bosek@protonmail.com}

\author{Wojciech Nadara}
\address{Institute of Informatics, University of Warsaw, Poland}
\email{wnadara@mimuw.edu.pl}

\author{Micha{\l} Pilipczuk}
\address{Institute of Informatics, University of Warsaw, Poland}
\email{michal.pilipczuk@mimuw.edu.pl}

\author{Anna Zych-Pawlewicz}
\address{Institute of Informatics, University of Warsaw, Poland}
\email{anka@mimuw.edu.pl}

\keywords{Dynamic data structures, bounded degeneracy, dominating set}

\subjclass[2020]{68P05, 68W27, 05C85}
\date{}

\begin{document}

% ============================================================================
\begin{abstract}
% ============================================================================
We consider the problem of dynamically maintaining information about a dominating set in an undirected graph on a fixed vertex set $V = \{1, \ldots, n\}$.
For parameters $d$ (degeneracy) and $k$ (the size bound on the sought dominating set) we present a fully dynamic data structure supporting edge insertions and deletions under the promise that the graph remains $d$-degenerate.
The data structure answers queries asking whether there exists a dominating set of size at most~$k$, and in the positive case can return such a set.
This is a Las~Vegas randomized data structure: the answer is always correct, while the running time is a random variable whose expectation is bounded by the stated estimates.
For a fixed randomness seed, the update operations are deterministic.
The update operations have amortized time $O(2^{4d}\cdot (d^3+\log^3 n))$, and a query has expected time $O(f(d,k) \cdot \log^3 n)$, where $f(d,k)$ is an explicit computable function of $d$ and $k$.
\end{abstract}

\maketitle

% ============================================================================
\section{Introduction}\label{sec:intro}
% ============================================================================

\subsection{Problem statement}

We consider the problem of dynamically maintaining information about a dominating set in an undirected graph.
Let $V = \{1, 2, \ldots, n\}$ be a fixed vertex set that does not change during the execution of the algorithm.
The graph $G = (V, E)$ is dynamic in the sense that the edge set $E \subseteq \binom{V}{2}$ can be modified by edge insertions and deletions.

A set of vertices $D \subseteq V$ is a \emph{dominating set} of the graph $G = (V, E)$ if every vertex $v \in V$ either belongs to~$D$ or has a neighbor in~$D$.
Formally, $\bigcup_{u \in D} \NbhC{u} = V$, where $\NbhC{u} := \{u\} \cup \Nbh(u)$ denotes the closed neighborhood of~$u$, and $\Nbh(u) := \{v \in V : \{u,v\} \in E\}$ denotes the open neighborhood.

\begin{definition}[$d$-degeneracy]\label{def:degen}
A graph $G = (V, E)$ is \emph{$d$-degenerate} if every nonempty induced subgraph of~$G$ contains a vertex of degree at most~$d$.
\end{definition}

\begin{lemma}[Degeneracy orderings]\label{lem:degen-order}
A graph $G=(V,E)$ is $d$-degenerate if and only if there exists an ordering $v_1,\ldots,v_n$ of~$V$ such that for every $i \in \{1,\ldots,n-1\}$ the vertex $v_i$ has at most $d$ neighbors among $\{v_{i+1},\ldots,v_n\}$.
\end{lemma}

\begin{proof}
Assume first that $G$ is $d$-degenerate.
Repeatedly choose a vertex of minimum degree in the current induced subgraph, remove it, and record it.
This process terminates and yields an ordering $v_n,\ldots,v_1$ in reverse removal order.
When $v_i$ was removed, it had at most $d$ neighbors remaining in the induced subgraph on $\{v_{i+1},\ldots,v_n\}$, proving the claimed property.

Conversely, assume such an ordering exists.
Let $H$ be any nonempty induced subgraph of~$G$ and let $v_i$ be the first vertex of~$H$ in the ordering.
Every neighbor of $v_i$ inside~$H$ appears after $v_i$ in the ordering, hence $v_i$ has at most $d$ neighbors in~$H$.
Thus every induced subgraph of~$G$ contains a vertex of degree at most~$d$, so $G$ is $d$-degenerate.
\end{proof}

Our goal is to construct a data structure that, for given parameters $d, k \in \NN$, maintains a $d$-degenerate graph under edge insertions and deletions and answers queries asking whether there exists a dominating set of size at most~$k$.

\subsection{Overview of the approach}\label{sec:overview}

Our data structure combines a deterministic update mechanism with a Las~Vegas query algorithm.
The update mechanism maintains a bounded-outdegree orientation of the current graph using the dynamic orientation data structure of Brodal and Fagerberg~\cite{BrodalFagerberg99}.
For a $d$-degenerate graph this yields an orientation with maximum out-degree $\Delta=4d$ (Section~\ref{sec:ds}).

The central auxiliary object is a \emph{bucket system} indexed by subsets of out-neighborhoods.
For each set $Z \subseteq V$ with $|Z|\le \Delta$ we define the bucket $B(Z)=\{u\in V^+ : Z \subseteq \Np(u)\}$, where $V^+$ denotes the set of non-isolated vertices (defined in Section~\ref{sec:buckets}).
Maintaining these buckets together with a collection of counters allows us to evaluate, for many sets $Z$, the quantities $|B(Z)\cap S|$ and the corresponding identifier sums for suitable random samples $S$.

The procedure \proc{Query} is based on the semi-ladder framework of Fabia\'nski, Pilipczuk, Siebertz, and Toru\'nczyk~\cite{FabianskiPST19}.
It alternates between a \emph{candidate oracle}, which (given a current witness set $W$) either constructs a size-$k$ set dominating $W$ or proves that none exists, and a \emph{witness oracle}, which (given a candidate set $D$) either certifies that $D$ dominates $V$ or produces a new vertex not dominated by~$D$.
The witness oracle uses inclusion--exclusion and a randomized isolation mechanism to recover such a witness in expected time, and repeats with resampled randomness until it succeeds, ensuring Las~Vegas correctness.

\subsection{Related work}\label{sec:related}

Fabia\'nski et al.~\cite{FabianskiPST19} introduced the progressive/semi-ladder framework and used it to obtain fixed-parameter tractable algorithms for domination and independence problems on sparse graph classes, including $d$-degenerate graphs.
The present work dynamizes the framework by providing update operations that maintain the information needed by the oracles, and by implementing a witness oracle through dynamic counting in the bucket system.

We use the fully dynamic bounded-outdegree orientation data structure of Brodal and Fagerberg~\cite{BrodalFagerberg99}; additionally, our implementation records all edges that change orientation in an update (Lemma~\ref{lem:bf-report}).
For background on sparse graph classes and degeneracy we refer to the monograph of Ne\v{s}et\v{r}il and Ossona de Mendez~\cite{NesetrilOssona12}.

\subsection{Computational model}\label{sec:model}

We work in the word-RAM model with word length $w = \Theta(\log n)$.
Throughout the paper, logarithms are base~$2$ and we use the convention $\log n := \max(1, \log_2 n)$.
In particular,
$w \geq \lceil \log_2(n+1) \rceil$ (and hence $2^w > n$).
Vertices are represented by numbers from $\{1, \ldots, n\}$, which fit in one machine word.
For a vertex $u \in V$ we define $\id(u) := u$ as its numeric identifier (a number in $\{1, \ldots, n\}$).
In this model, arithmetic and bit operations on $w$-bit words, including addition, subtraction, comparison, shifts, and multiplication in $\ZZ_{2^w}$, take constant time~$O(1)$.
We represent dictionaries by balanced binary search trees, which support insert, delete, and lookup in $O(\log M)$ time for a dictionary with $M$ elements; see, e.g.,~\cite[Chapter~13]{CLRS}.

The witness oracle evaluates inclusion--exclusion sums whose magnitudes are bounded by $2^k\cdot n$.
We represent such integers explicitly as sequences of machine words in base $2^w$; addition, subtraction, and comparison then take time $O(k+1)$ (Lemma~\ref{lem:multiword} in Appendix~\ref{app:multiword}).

\subsection{Main result}

The main result of this paper is the following theorem.

We use the derived parameter $\Delta := 4d$.
For notational convenience we define
\[
p(d,k) := \max(2,k)^{3d+3}
\]
and
\[
f(d,k) := (1+\Delta)^2 \cdot p(d,k)^3 \cdot 3^{p(d,k)}
          + (1+\Delta)^2 \cdot p(d,k) \cdot 2^k \cdot k^3
          + p(d,k)\cdot d \cdot 2^\Delta.
\]

\begin{theorem}[Main theorem]\label{thm:main}
Let $n, d, k \in \NN$ and let $V = \{1, \ldots, n\}$.
There exists a fully dynamic Las~Vegas randomized data structure which, under the assumption that the maintained graph $G = (V, E)$ remains $d$-degenerate, supports the following operations.

The procedure $\proc{Init}(n, d, k)$ initializes the structure for the edgeless graph $G = (V, \emptyset)$ in time $O(1)$.

The procedure $\proc{InsertEdge}(u, v)$ inserts the edge $\{u, v\}$ into the graph (if it does not already exist) in amortized time $O(2^{4d}\cdot (d^3+\log^3 n))$.

The procedure $\proc{DeleteEdge}(u, v)$ deletes the edge $\{u, v\}$ from the graph (if it exists) in amortized time $O(2^{4d}\cdot (d^3+\log^3 n))$.

The procedure $\proc{Query}()$ returns, in expected time $O(f(d,k) \cdot \log^3 n)$, a dominating set of size at most~$k$ if one exists, or the special value~$\bot$ indicating that no solution exists.

The data structure uses $O(n+m+m \cdot 2^\Delta \cdot \log^2 n)$ machine words of memory, where $m$ is the current number of edges.
Using Corollary~\ref{cor:edge-bound}, this is bounded by $O(n \cdot d \cdot 2^{4d} \cdot \log^2 n)$ machine words.
\end{theorem}

The data structure is Las~Vegas: the answer returned by $\proc{Query}$ is always correct, while its running time is a random variable with expected value bounded by the stated estimate.
Randomness is used only to sample the current seed $\sigma$ defining the random labels (Section~\ref{sec:labels}); the seed is initialized on demand and may be replaced by resampling in the witness oracle.
For a fixed seed, the update operations $\proc{InsertEdge}$ and $\proc{DeleteEdge}$ are deterministic.

The proof of Theorem~\ref{thm:main} is presented in the subsequent sections.
In Section~\ref{sec:ds} we describe the data structure and analyze its space complexity.
In Section~\ref{sec:update} we present the update procedures together with proofs of correctness and complexity.
In Section~\ref{sec:query} we describe the $\proc{Query}$ procedure, including the semi-ladder framework and the candidate and witness oracles (Subsections~\ref{sec:candidate} and~\ref{sec:witness}).
In Section~\ref{sec:main-proof} we combine all components into the proof of the main theorem.


% ============================================================================
\section{Interface specification}\label{sec:interface}
% ============================================================================

In this section we precisely define the interface of the data structure.
We use the parameter $\Delta$ and the functions $p(d,k)$ and $f(d,k)$ as defined in Section~\ref{sec:intro}.

\noindent\proc{Init}$(n,d,k)$ initializes the data structure for the edgeless graph $G=(V,\emptyset)$ on $V=\{1,\ldots,n\}$ and runs in time $O(1)$.

\noindent\proc{InsertEdge}$(u,v)$ inserts the edge $\{u,v\}$ if it is not present.
It is required that after the insertion the graph remains $d$-degenerate; if this precondition is violated, the behavior is undefined.
The amortized running time is $O(2^{4d}\cdot (d^3+\log^3 n))$.

\noindent\proc{DeleteEdge}$(u,v)$ deletes the edge $\{u,v\}$ if it is present.
The amortized running time is $O(2^{4d}\cdot (d^3+\log^3 n))$.

\noindent\proc{Query}() returns a dominating set $D$ with $|D|\le k$ if one exists, and otherwise returns~$\bot$.
The procedure is Las~Vegas: the returned answer is always correct, and the running time is a random variable.
The expected running time is $O(f(d,k) \cdot \log^3 n)$.
For a fixed randomness seed, the update procedures $\proc{InsertEdge}$ and $\proc{DeleteEdge}$ are deterministic, while $\proc{Query}$ may resample the seed.

Space complexity: the data structure uses $O(n+m+m \cdot 2^{4d} \cdot \log^2 n)$ machine words, where $m$ is the current number of edges (Theorem~\ref{thm:space}).


% ============================================================================
\section{Data structure}\label{sec:ds}
% ============================================================================

In this section we describe the components of the data structure and analyze its space usage.

\subsection{Dynamic orientation with bounded out-degree}

A key tool is the ability to dynamically maintain an orientation of the graph with bounded out-degree.
An orientation of an undirected graph $G = (V, E)$ is a directed graph $\vec{G} = (V, \vec{E})$ in which for every edge $\{u, v\} \in E$ exactly one of the arcs $(u, v)$ or $(v, u)$ belongs to $\vec{E}$.
For a vertex $u \in V$ we define its \emph{out-neighborhood} as $\Np(u) := \{v \in V : (u, v) \in \vec{E}\}$.

\begin{definition}[Arboricity]\label{def:arb}
The \emph{arboricity} of a graph $G$, denoted $\arb(G)$, is the minimum number of forests into which the edge set of~$G$ can be decomposed.
\end{definition}

\begin{theorem}[Nash--Williams~\cite{NashWilliams64}]\label{thm:nash-williams}
For every graph $G=(V,E)$ with $|V|\ge 2$ we have
\[
\arb(G)=\max_{H \subseteq G,\ |V(H)|\ge 2}\left\lceil \frac{|E(H)|}{|V(H)|-1} \right\rceil,
\]
where the maximum ranges over (not necessarily induced) subgraphs~$H$ of~$G$.
\end{theorem}

We next relate degeneracy to arboricity.

\begin{lemma}[Degeneracy implies bounded arboricity]\label{lem:arb}
If a graph $G$ is $d$-degenerate, then $\arb(G) \leq d$.
\end{lemma}

\begin{proof}
By Theorem~\ref{thm:nash-williams}, it suffices to show that for every subgraph $H$ of~$G$ with $m:=|V(H)|\ge 2$ we have $|E(H)| \le d(m-1)$.
If $G$ is $d$-degenerate then every subgraph $H$ of~$G$ is also $d$-degenerate.
Fix such~$H$ and take a degeneracy ordering of~$H$ given by Lemma~\ref{lem:degen-order}.
Let $v_1,\ldots,v_m$ be such an ordering and orient each edge $\{v_i,v_j\}$ with $i<j$ as the arc $(v_i,v_j)$.
Then every vertex except the last has out-degree at most~$d$, and hence $|E(H)| \le d(m-1)$.
Therefore $\arb(G) \le d$.
\end{proof}

\begin{corollary}\label{cor:edge-bound}
If $G$ is $d$-degenerate on $n$ vertices and $m$ edges, then $m \leq d(n-1)$, and in particular $m/n \leq d$.
\end{corollary}

\begin{proof}
Fix a degeneracy ordering $v_1,\ldots,v_n$ and orient each edge $\{v_i,v_j\}$ with $i<j$ as the arc $(v_i,v_j)$.
Then every vertex $v_i$ has out-degree at most~$d$, and $v_n$ has out-degree~$0$.
Thus $m$ equals the number of oriented edges and is at most $d(n-1)$.
\end{proof}

We use the following result of Brodal and Fagerberg~\cite[Theorem~3]{BrodalFagerberg99}.

\begin{theorem}[Brodal--Fagerberg]\label{thm:bf}
There exists a deterministic data structure that maintains a graph of arboricity at most $\alpha$ under edge insertions and deletions.
The data structure stores an orientation $\vec{G}$ of~$G$ with maximum out-degree~$4\alpha$, i.e., for every vertex~$u$ we have $|\Np(u)| \leq 4\alpha$.
An edge insertion has amortized cost~$O(1)$, an edge deletion has amortized cost $O(\alpha + \log n)$, and the amortized number of edges that change orientation in a single operation is $O(\alpha + \log n)$.
The data structure uses $O(n + m)$ memory for a graph with $n$ vertices and $m$ edges.
\end{theorem}

\begin{lemma}[Reporting reoriented edges]\label{lem:bf-report}
There exists an implementation of the data structure from Theorem~\ref{thm:bf} such that each update additionally outputs the list of edges whose orientation changed during this update.
Producing this list takes $O(r)$ time, where $r$ is the number of reoriented edges, and does not affect the amortized bounds from Theorem~\ref{thm:bf}.
\end{lemma}

\begin{proof}
We implement the structure from Theorem~\ref{thm:bf} so that whenever it changes the stored orientation of an edge (that is, flips its direction in~$\vec{G}$), it appends this edge to an output list.
Maintaining such a list adds $O(1)$ overhead per reoriented edge, hence $O(r)$ total time, and does not change the amortized bounds.
\end{proof}

By Lemma~\ref{lem:arb}, for a $d$-degenerate graph we can apply Theorem~\ref{thm:bf} with parameter $\alpha = d$, obtaining an orientation with out-degree at most $\Delta$ (in particular, at most $4d$).

\subsection{Neighbor dictionaries}

For vertices of nonzero degree in the undirected graph $G$ we maintain a dictionary $\Nbh(u)$ containing all neighbors of~$u$ and a dictionary $\Np(u)$ containing the endpoints of edges outgoing from $u$ in the orientation~$\vec{G}$.
Isolated vertices (of degree~$0$) are handled implicitly: for $u \notin V^+$ we store no per-vertex dictionaries and we interpret $\Nbh(u)=\Np(u)=\emptyset$.
Membership queries $v \in \Nbh(u)$ take time $O(\log n)$.
We also iterate over all elements of $\Np(u)$ and $\Nbh(u)$; an in-order traversal of a balanced search tree enumerates all stored keys in time linear in the dictionary size.

\subsection{Bucket system}\label{sec:buckets}

Let $V^+ := \{u \in V : \deg_G(u) > 0\}$ denote the set of non-isolated vertices, which are stored explicitly.
We also maintain the set of isolated vertices $V \setminus V^+$ as a collection of disjoint identifier intervals, which allows us in time $O(\log n)$ to find the smallest isolated vertex (if it exists), as well as the next isolated vertex after a given identifier.
We also store its cardinality, so $|V^+| = n - |V \setminus V^+|$ is available in time $O(1)$.
Details of this representation are given in Appendix~\ref{app:intervals}.

The bucket system provides fast access to the set of vertices whose out-neighborhood contains a prescribed set $Z$ of size at most~$\Delta$.
This information is used to implement the candidate oracle (Section~\ref{sec:candidate}) and, together with randomized counters, the witness oracle (Section~\ref{sec:witness}).

For a set $Z \subseteq V$ of size $|Z| \leq \Delta$ we define the \emph{bucket} $B(Z) := \{u \in V^+ : Z \subseteq \Np(u)\}$ as the set of non-isolated vertices whose out-neighborhood contains all of~$Z$.
For $|Z|>\Delta$ we have $B(Z)=\emptyset$, since $|\Np(u)|\le \Delta$ for every vertex~$u$.
We store buckets in a global dictionary, where the key is the set~$Z$ represented as a sorted sequence of vertex identifiers.
Comparing two keys costs $O(\Delta)$, so dictionary operations take time $O(\Delta \log M)$ for a dictionary of size~$M$.
At any time, the number of nonempty buckets satisfies
\[
M \le \sum_{u \in V^+} 2^{|\Np(u)|} \le |V^+|\cdot 2^\Delta \le n \cdot 2^\Delta.
\]
Hence $\log M \le \log n + \Delta$ and dictionary operations take time $O(\Delta(\log n + \Delta))$.

We maintain a bucket object only when $B(Z)$ is nonempty; it stores the key~$Z$, the element set $B(Z)$, and the counter arrays defined in Section~\ref{sec:labels}.
For each vertex $u\in V^+$ we maintain a list of all sets $Z\subseteq \Np(u)$ such that $u\in B(Z)$; this list has size exactly $2^{|\Np(u)|}\le 2^\Delta$.
To support $O(1)$ modifications of bucket memberships, each bucket $B(Z)$ is represented as a doubly linked list of vertices with a stored head pointer and size.
Each registration record for a pair $(u,Z)$ stores a pointer to the bucket object for~$Z$ and a pointer to the list node representing~$u$ in the list for~$B(Z)$.
Thus, once the record for $(u,Z)$ is available, removing or inserting $u$ into $B(Z)$ takes $O(1)$ pointer updates; updating the associated counters takes $O(\log^2 n)$ time per insertion/deletion.

Finally, we maintain iterable lists of the current set $V^+$ and of all nonempty buckets.
These are used only during resampling in the witness oracle to traverse all registration pairs $(u,Z)$ with $u\in B(Z)$.

\subsection{Random labels and counters}\label{sec:labels}

Fix an integer constant $c_0:=7$ and let $\lambda := \lceil c_0 \log n \rceil$.
This value of $c_0$ is chosen so that the failure probability bound in Theorem~\ref{thm:domwitness} yields $q<n^{-1}$ for all $n$.
The data structure maintains a current randomness seed~$\sigma$ that describes functions $h_1, \ldots, h_\lambda \colon V \to \{0, 1, \ldots, 2^{2w} - 1\}$ and we set $R_j(u) := h_j(u)$.
The seed is sampled on demand and then kept fixed until it is replaced by resampling in the witness oracle (Section~\ref{sec:witness}).
For a fixed seed, all update operations are deterministic.

\begin{lemma}[Implementable pairwise-independent hashing]\label{lem:hash-impl}
There exists a family $\mathcal{H}$ of hash functions $h\colon V\to \{0,1,\ldots,2^w-1\}$ such that a uniformly random $h\in\mathcal{H}$ can be described using $O(1)$ machine words and evaluated in $O(1)$ word-RAM time, and for any two distinct vertices $u,v\in V$ and any $a,b\in\{0,1,\ldots,2^w-1\}$ we have $\Pr(h(u)=a \land h(v)=b)=2^{-2w}$.
\end{lemma}

\begin{proof}
See, e.g.,~\cite{CarterWegman79,Dietzfelbinger96} for explicit constructions.
\end{proof}

We sample the functions $h_1,\ldots,h_\lambda$ independently from each other.
The seed~$\sigma$ stores the descriptions of these functions and occupies $O(\lambda)=O(\log n)$ machine words.
We implement $h_j$ by sampling two functions $h_j^{(0)}, h_j^{(1)} \colon V \to \{0, 1, \ldots, 2^{w}-1\}$ independently from $\mathcal{H}$ (Lemma~\ref{lem:hash-impl}) and setting
\[
h_j(u) := h_j^{(1)}(u)\cdot 2^{w} + h_j^{(0)}(u).
\]
We represent $h_j(u)$ as the pair of machine words $(h_j^{(1)}(u), h_j^{(0)}(u))$, so evaluating $R_j(u)$ and comparing it with the threshold $2^{2w-i-1}$ takes $O(1)$ time.
Since the two components are sampled independently and each is pairwise independent, the resulting family for $h_j$ is pairwise independent over the range $\{0,1,\ldots,2^{2w}-1\}$.
In particular, for any two distinct vertices $u, v \in V$ and any $a,b \in \{0,1,\ldots,2^{2w}-1\}$ we have $\Pr(h_j(u) = a \land h_j(v) = b) = 2^{-4w}$, and hence each value $h_j(u)$ is uniform over $\{0,1,\ldots,2^{2w}-1\}$.
The isolation analysis in Lemma~\ref{lem:isolation} uses only this pairwise-independence property.
The independence of the samples $h_1, \ldots, h_\lambda$ is used to bound the probability that isolation fails for all $j$ in Theorem~\ref{thm:domwitness}.

For $i \in \{0, 1, \ldots, 2w-1\}$ and $j \in \{1, \ldots, \lambda\}$ we define the set $S_{i,j} := \{u \in V : R_j(u) < 2^{2w-i-1}\}$.
Since each value $R_j(u)=h_j(u)$ is uniform over $\{0, 1, \ldots, 2^{2w}-1\}$, we have
\[
\Pr(u \in S_{i,j}) = \Pr(R_j(u) < 2^{2w-i-1}) = \frac{2^{2w-i-1}}{2^{2w}} = 2^{-i-1} =: p_i.
\]
For fixed $j$ and distinct vertices $u,v \in V$, pairwise independence of~$h_j$ implies that the events $u \in S_{i,j}$ and $v \in S_{i,j}$ are independent, and hence $\Pr(u \in S_{i,j} \land v \in S_{i,j}) = p_i^2$.

\paragraph{Identifier sums.}
For every finite set $A \subseteq V$ we define
\[
\idsum(A) := \sum_{u \in A} \id(u) \bmod 2^w.
\]

For each nonempty bucket $B(Z)$ and each pair $(i,j)$ we store the counter $C_{Z,i,j} := |B(Z) \cap S_{i,j}|$ and the identifier sum $T_{Z,i,j} := \sum_{u \in B(Z) \cap S_{i,j}} \id(u) \mod 2^w$.
We also store analogous global counters $C_{\mathrm{all},i,j}$ and $T_{\mathrm{all},i,j}$ for the set $V^+$ (vertices of nonzero degree), which are stored explicitly in the data structure.
In particular, for the initial edgeless graph we have $V^+ = \emptyset$, so all these counters are equal to~$0$.

\subsection{Space usage analysis}

\begin{theorem}[Space complexity]\label{thm:space}
The data structure uses $O(n+m+m \cdot 2^\Delta \cdot \log^2 n)$ machine words of memory for a graph with $n$ vertices and $m$ edges.
Since $\Delta=4d$, this is $O(n+m+m \cdot 2^{4d} \cdot \log^2 n)$ machine words.
Using Corollary~\ref{cor:edge-bound}, it is also bounded by $O(n \cdot d \cdot 2^{4d} \cdot \log^2 n)$ machine words.
\end{theorem}

\begin{proof}
The dynamic orientation of Brodal--Fagerberg uses $O(n+m)$ memory (Theorem~\ref{thm:bf}).
The neighbor dictionaries store every undirected edge in the two endpoint dictionaries and are allocated only for vertices of positive degree, hence use $O(m)$ memory.
Representing the set of isolated vertices as disjoint intervals requires $O(|V^+|)$ memory.
By Lemma~\ref{lem:isolated-intervals}, the number of stored intervals is at most $|V^+|+1$, and hence the interval representation uses $O(|V^+|)=O(m)$ words.

Each vertex $u$ with $\deg(u) > 0$ is registered in exactly $2^{|\Np(u)|} \leq 2^\Delta$ buckets.
The number of vertices of nonzero degree is at most~$2m$, so the total number of registration records is at most $2m \cdot 2^\Delta$.
The number of nonempty buckets is bounded by the same quantity.
For each bucket we store $O(\log^2 n)$ counters.
Random labels are computed on demand via the hash functions.
Storing the seed $\sigma$ (that is, descriptions of $h_1,\ldots,h_\lambda$) requires $O(\lambda)=O(\log n)$ machine words, which is subsumed by the $O(n+m)$ term.

Summing up, the bucket system uses $O(m \cdot 2^\Delta \cdot \log^2 n)$ words.
Together with the $O(n+m)$ memory needed for the dynamic orientation and the neighbor dictionaries, this gives $O(n+m+m \cdot 2^\Delta \cdot \log^2 n)$.
\end{proof}


% ============================================================================
\section{Update procedures}\label{sec:update}
% ============================================================================

\subsection{Procedure \proc{Init}}

The procedure $\proc{Init}(n, d, k)$ creates the structure for the edgeless graph $G = (V, \emptyset)$ in time $O(1)$ using lazy initialization.
First, it stores the input parameters $n, d, k$ in global memory and computes the derived constants $\Delta = 4d$ and $\lambda = \lceil c_0 \log n \rceil$ (where $c_0=7$ is the fixed constant from Section~\ref{sec:labels}).
It initializes the dynamic orientation structure of Theorem~\ref{thm:bf} for the edgeless graph and allocates empty dictionary objects for the neighbor dictionaries and the bucket system (implemented as balanced binary search trees), without iterating over the vertex set.
Memory for specific vertices is allocated only at the first call to \proc{InsertEdge} or \proc{DeleteEdge} involving them.
The set $V^+$ is initially empty, while the set of isolated vertices $V \setminus V^+$ is initialized as a single interval $[1,n]$.
Since $V^+=\emptyset$, the randomness seed $\sigma$ and the global counter arrays $C_{\mathrm{all},i,j},T_{\mathrm{all},i,j}$ are not needed at this point.
They are initialized on demand when the first non-isolated vertex appears, and then maintained by the update procedures as described below.
\begin{lemma}[Correctness and complexity of \proc{Init}]\label{lem:init}
The procedure \proc{Init} correctly initializes the structure representing an edgeless graph and runs in time $O(1)$.
\end{lemma}

\begin{proof}
An edgeless graph does not require storing any vertices or buckets explicitly: we have $V^+=\emptyset$ and therefore no bucket is nonempty.
The interval representation $[1,n]$ correctly represents the set of isolated vertices.
Since $V^+=\emptyset$, all bucket counters and global counters are equal to~$0$ by definition, independently of the choice of the seed~$\sigma$.
Therefore, \proc{Init} can leave $\sigma$ undefined and allocate no counter arrays.
The procedure performs only $O(1)$ operations on machine words and hence runs in time $O(1)$.
\end{proof}

\subsection{Auxiliary procedure \proc{Reregister}}

After the set $\Np(u)$ changes (due to edge reorientation), the registrations of vertex~$u$ in the buckets must be updated.
Let $\Np_{\mathrm{old}}(u)$ and $\Np_{\mathrm{new}}(u)$ denote the out-neighborhoods of~$u$ before and after the change, respectively.
Before the change, the vertex $u$ belongs exactly to the buckets $B(Z)$ with $Z \subseteq \Np_{\mathrm{old}}(u)$, and after the change it should belong exactly to the buckets $B(Z)$ with $Z \subseteq \Np_{\mathrm{new}}(u)$.
Thus $\proc{Reregister}(u)$ updates the bucket memberships of~$u$ by removing $u$ from all buckets indexed by subsets of $\Np_{\mathrm{old}}(u)$ and then inserting $u$ into all buckets indexed by subsets of $\Np_{\mathrm{new}}(u)$.
Whenever $u$ is removed from or inserted into a bucket $B(Z)$, the counters $C_{Z,i,j}$ and $T_{Z,i,j}$ are updated according to whether $u \in S_{i,j}$.
Buckets are created on demand when they become nonempty and removed from the dictionary when they become empty.

\begin{lemma}[Correctness of \proc{Reregister}]\label{lem:rereg-correct}
After executing $\proc{Reregister}(u)$, the invariants hold: $u \in B(Z)$ if and only if $Z \subseteq \Np(u)$, and all counters $C_{Z,i,j}$ and $T_{Z,i,j}$ are correct.
\end{lemma}

\begin{proof}
Let $\Np_{\mathrm{old}}(u)$ denote the out-neighborhood of $u$ before the procedure, and let $\Np_{\mathrm{new}}(u)$ denote the out-neighborhood after the procedure.
During the removal phase the procedure removes $u$ from every bucket $B(Z)$ with $Z \subseteq \Np_{\mathrm{old}}(u)$.
During the insertion phase it inserts $u$ into every bucket $B(Z)$ with $Z \subseteq \Np_{\mathrm{new}}(u)$.

Thus, after the two phases, for every set $Z$ we have $u \in B(Z)$ if and only if $Z \subseteq \Np_{\mathrm{new}}(u)=\Np(u)$.

It remains to argue correctness of the counters.
Recall the definitions from Section~\ref{sec:labels}:
$C_{Z,i,j} := |B(Z)\cap S_{i,j}|$ and $T_{Z,i,j} := \sum_{x \in B(Z)\cap S_{i,j}} \id(x) \bmod 2^w$.
Whenever $u$ is removed from a bucket $B(Z)$, we decrement $C_{Z,i,j}$ and subtract $\id(u)$ from $T_{Z,i,j}$ exactly for those pairs $(i,j)$ for which $u \in S_{i,j}$; hence after the removal the counter values again satisfy the defining equalities for the updated bucket.
Analogously, whenever $u$ is inserted into a bucket $B(Z)$, we increment $C_{Z,i,j}$ and add $\id(u)$ to $T_{Z,i,j}$ for exactly those pairs with $u \in S_{i,j}$, restoring correctness of the counter definitions after the insertion.
All other bucket elements are unchanged throughout the procedure, so all counters not associated with $u$ remain correct.
Buckets created during insertion start with empty element lists and zero counters and become correct after inserting~$u$; buckets deleted during removal are empty and their counters are no longer referenced.
Therefore, after $\proc{Reregister}(u)$ all counters are correct.
\end{proof}

\begin{lemma}[Complexity of \proc{Reregister}]\label{lem:rereg-time}
The procedure $\proc{Reregister}(u)$ runs in time $O(2^\Delta \cdot (\Delta(\log n + \Delta) + \log^2 n))$.
\end{lemma}

\begin{proof}
During the removal phase we process at most $2^\Delta$ buckets corresponding to subsets of $\Np_{\mathrm{old}}(u)$.
During the insertion phase we process at most $2^\Delta$ buckets corresponding to subsets of $\Np_{\mathrm{new}}(u)$.
For each bucket we perform a dictionary operation (cost $O(\Delta(\log n + \Delta))$) and update $O(\log^2 n)$ counters.
The total cost is $O(2^\Delta \cdot (\Delta(\log n + \Delta) + \log^2 n))$.
\end{proof}

\subsection{Procedure \proc{InsertEdge}}

The procedure $\proc{InsertEdge}(u,v)$ changes the represented graph only if $\{u,v\}\notin E$.
In this case it inserts $v$ into $\Nbh(u)$ and $u$ into $\Nbh(v)$.
If the current seed $\sigma$ has not been initialized yet, we sample it and initialize the global counter arrays $C_{\mathrm{all},i,j},T_{\mathrm{all},i,j}$ to~$0$ (this can happen only while $V^+=\emptyset$).
If an endpoint $x\in\{u,v\}$ was isolated before the insertion (that is, $x\notin V^+$), then $x$ is removed from the interval representation of isolated vertices, added to~$V^+$, and its per-vertex objects are allocated: the dictionaries $\Nbh(x)$ and $\Np(x)$ and an initially empty registration list.
The global counters $C_{\mathrm{all},i,j}$ and $T_{\mathrm{all},i,j}$ are updated by adding the contribution of every newly activated vertex.

Next, the procedure updates the maintained orientation using the insertion operation of Theorem~\ref{thm:bf}.
By Lemma~\ref{lem:bf-report}, we obtain the list of edges whose orientation changed during this update, and hence the set of vertices $x$ whose out-neighborhood $\Np(x)$ changed.
For each such vertex (as well as for the endpoints $u$ and~$v$ of the inserted edge) the procedure invokes $\proc{Reregister}(x)$.

\subsection{Procedure \proc{DeleteEdge}}

The procedure $\proc{DeleteEdge}(u,v)$ changes the represented graph only if $\{u,v\}\in E$.
In this case it removes $v$ from $\Nbh(u)$ and $u$ from $\Nbh(v)$.

Next, it updates the maintained orientation using the deletion operation of Theorem~\ref{thm:bf}.
By Lemma~\ref{lem:bf-report}, we obtain the list of edges whose orientation changed during this update, and hence the set of vertices $x$ whose out-neighborhood $\Np(x)$ changed.
For each such vertex (as well as for the endpoints $u$ and~$v$ of the deleted edge) the procedure invokes $\proc{Reregister}(x)$.

Finally, if after deleting the edge an endpoint $x\in\{u,v\}$ becomes isolated (that is, $\Nbh(x)=\emptyset$), then $x$ is removed from all buckets using its registration list while updating the bucket counters, its contribution is subtracted from the global counters $C_{\mathrm{all},i,j},T_{\mathrm{all},i,j}$, and $x$ is inserted into the interval representation of isolated vertices.

\subsection{Correctness and amortized running time}

\begin{lemma}[Correctness of updates]\label{lem:update-correct}
After executing $\proc{InsertEdge}$ or $\proc{DeleteEdge}$, the structure correctly represents the updated graph.
\end{lemma}

\begin{proof}
Correctness of the neighbor dictionaries $\Nbh(\cdot)$ follows from explicit insertions and deletions.
Correctness of the orientation is guaranteed by Theorem~\ref{thm:bf}.
Correctness of the sets $V^+$ and $V \setminus V^+$ follows from explicit updates after each change of a vertex degree.
Correctness of the buckets and counters $C_{Z,i,j},T_{Z,i,j}$ follows from Lemma~\ref{lem:rereg-correct}, since $\proc{Reregister}$ is called for every vertex whose $\Np(\cdot)$ changes, and a vertex that becomes isolated is removed from all buckets with corresponding counter updates.
Correctness of the global counters $C_{\mathrm{all},i,j},T_{\mathrm{all},i,j}$ follows from explicitly adding/subtracting a vertex contribution when it moves between $V^+$ and $V \setminus V^+$.
\end{proof}

\begin{lemma}[Update time]\label{lem:update-time}
The amortized running time of $\proc{InsertEdge}$ and $\proc{DeleteEdge}$ is $O(2^{4d}\cdot (d^3+\log^3 n))$.
\end{lemma}

\begin{proof}
Updating the dictionaries $\Nbh(\cdot)$ costs $O(\log n)$.
Handling possible changes of vertex status between $V^+$ and $V \setminus V^+$ costs $O(\log^2 n)$ per affected vertex:
updating the interval representation of isolated vertices takes $O(\log n)$ time by Lemma~\ref{lem:isolated-intervals}, and updating the global counters $C_{\mathrm{all},i,j},T_{\mathrm{all},i,j}$ touches $(2w)\cdot \lambda = O(\log^2 n)$ pairs $(i,j)$ and takes $O(\log^2 n)$ time.
If an endpoint becomes isolated after a deletion, we traverse its registration list and remove it from all buckets while updating the counters (and deleting buckets that become empty).
The registration list has size at most $2^\Delta$, and each processed record performs the same type of bucket and counter updates as the first stage of $\proc{Reregister}$, hence costs $O(\Delta(\log n + \Delta) + \log^2 n)$.
Since at most two vertices can become isolated in one update, this contributes $O(2^\Delta \cdot (\Delta(\log n + \Delta) + \log^2 n))$ total, which is subsumed by the stated bound.
By Theorem~\ref{thm:bf}, the amortized number of edges that change orientation is $O(d + \log n)$.
By Lemma~\ref{lem:rereg-time}, each call to $\proc{Reregister}$ costs $O(2^\Delta \cdot (\Delta(\log n + \Delta) + \log^2 n))$.

The total amortized cost is:
\[
O(\log n) + O(d + \log n) \cdot O(2^\Delta \cdot (\Delta(\log n + \Delta) + \log^2 n)) = O(2^\Delta \cdot (d + \log n) \cdot (\Delta(\log n + \Delta) + \log^2 n)).
\]
Recalling that $\Delta = 4d$, the right-hand side is
\[
O(2^{4d}\cdot (d + \log n) \cdot (d(\log n + d) + \log^2 n))
= O(2^{4d}\cdot (d+\log n)^3)
= O(2^{4d}\cdot (d^3+\log^3 n)).
\]
\end{proof}


% ============================================================================
\section{Procedure \proc{Query}}\label{sec:query}
% ============================================================================

The procedure $\proc{Query}$ is based on a semi-ladder algorithm inspired by the work of Fabia\'nski, Pilipczuk, Siebertz, and Toru\'nczyk~\cite{FabianskiPST19}.

\subsection{Overview}\label{sec:query-overview}

The procedure $\proc{Query}$ maintains a witness set $W\subseteq V$ and repeats the following conceptual step:
it computes a candidate set $D$ of size at most $k$ dominating~$W$ (if one exists), and then either certifies that $D$ dominates all of~$V$ or extracts a new witness vertex $r\notin \Dom(D)$ and adds it to~$W$.
The candidate step is implemented by the candidate oracle (Section~\ref{sec:candidate}) and is deterministic.
The witness step is implemented by the witness oracle (Section~\ref{sec:witness}) and is Las~Vegas randomized: it always returns a correct answer, and its running time is a random variable due to possible resampling of the hash seed.

Termination is guaranteed by bounding the semi-ladder index of the candidate--witness relation for $d$-degenerate graphs.
More precisely, the semi-ladder framework ensures that each successful round strictly increases $|W|$, and Theorem~\ref{thm:sd-bound} bounds the number of rounds by a function $p(d,k)$ depending only on the parameters.
Thus the only source of randomness is confined to the witness oracle, while the progress argument is deterministic.

\subsection{Basic notions}

\begin{definition}[Candidate--witness bipartite graph]\label{def:bipartite}
For a graph $G = (V, E)$ and a parameter~$k$ we define the bipartite graph $H_G = (L, R, E_H)$ as follows: $R := V$ is the set of \emph{witnesses}, $L := V^k$ is the set of \emph{candidates} (ordered $k$-tuples), and an edge $(\bar{x}, y) \in E_H$ exists if and only if $y \in \bigcup_{i=1}^k \NbhC{x_i}$.
\end{definition}

The graph $G$ has a dominating set of size at most~$k$ if and only if there exists a candidate $\bar{x} \in L$ that is adjacent to all witnesses in~$H_G$.
\par
Any dominating set $D \subseteq V$ with $|D| \leq k$ can be represented by a candidate $\bar{x}\in V^k$ by listing the elements of~$D$ and repeating arbitrary vertices to obtain a $k$-tuple.

\begin{definition}[Semi-ladder]\label{def:semiladder}
In a bipartite graph $H = (L, R, E)$, sequences of pairwise distinct vertices $a_1, \ldots, a_\ell \in L$ and $b_1, \ldots, b_\ell \in R$ form a \emph{semi-ladder of order~$\ell$} if $(a_i, b_i) \notin E$ for every~$i$ and $(a_i, b_j) \in E$ for all $i > j$.
The \emph{semi-ladder index} of~$H$ is the maximum~$\ell$ such that $H$ contains a semi-ladder of order~$\ell$.
\end{definition}

\begin{lemma}[Semi-ladder algorithm]\label{lem:sd-alg}
Let $H = (L, R, E)$ be a bipartite graph with semi-ladder index at most~$p$.
The algorithm maintains a set of witnesses $W \subseteq R$, initially empty, and in each round searches for a candidate $a \in L$ such that $W \subseteq N_H(a)$.
If no such~$a$ exists, the algorithm terminates with a negative answer.
If such~$a$ exists and $N_H(a) = R$, the algorithm terminates and returns~$a$.
Otherwise it chooses $b \in R \setminus N_H(a)$, adds~$b$ to~$W$, and continues.
The algorithm terminates after at most~$p$ rounds.
\end{lemma}

\begin{proof}
Suppose the algorithm executes $\ell$ full rounds, choosing candidates $a_1, \ldots, a_\ell$ and witnesses $b_1, \ldots, b_\ell$.
We show that these sequences form a semi-ladder of order~$\ell$, which implies $\ell \leq p$.

Witness $b_i$ was chosen as an element of $R \setminus N_H(a_i)$, so $(a_i, b_i) \notin E$.
For $i > j$: the witness $b_j$ was added to~$W$ in round~$j$, and the candidate $a_i$ was chosen in round~$i > j$ so that $W \subseteq N_H(a_i)$.
Since $b_j \in W$ at the moment $a_i$ was chosen, we have $(a_i, b_j) \in E$.
Thus the sequences $a_1, \ldots, a_\ell$ and $b_1, \ldots, b_\ell$ form a semi-ladder of order~$\ell$.
\end{proof}

\subsection{Bounding the semi-ladder index}

\begin{lemma}[Excluding large bicliques]\label{lem:biclique}
A $d$-degenerate graph does not contain $K_{d+1, d+1}$ as a subgraph.
\end{lemma}

\begin{proof}
Suppose $G$ contains $K_{d+1, d+1}$ with sides $A$ and~$B$, where $|A| = |B| = d+1$.
The induced subgraph $G[A \cup B]$ has $2(d+1)$ vertices, each of degree at least $d+1$ (it is adjacent to all vertices on the opposite side).
This contradicts $d$-degeneracy, which requires that every nonempty induced subgraph contains a vertex of degree at most~$d$.
\end{proof}

\begin{lemma}[Index bound for the neighborhood relation]\label{lem:delta1-semiladder}
Let $G$ be a graph that does not contain $K_{t,t}$ as a subgraph.
Let $H_1 = (V, V, E_1)$ be the bipartite graph where $(x, y) \in E_1$ if and only if $y \in \NbhC{x}$.
Then the semi-ladder index of $H_1$ is smaller than $3t$.
\end{lemma}

\begin{proof}
Suppose there is a semi-ladder of order $\ell := 3t$ with vertices $a_1, \ldots, a_\ell$ and $b_1, \ldots, b_\ell$.
By the definition of a semi-ladder: $b_i \notin \NbhC{a_i}$ for every~$i$ (so $b_i \neq a_i$ and $\{a_i, b_i\} \notin E$) and $b_j \in \NbhC{a_i}$ for $i > j$ (so $b_j = a_i$ or $\{a_i, b_j\} \in E$).

Let $A := \{a_{t+1}, \ldots, a_{3t}\}$ and $B := \{b_1, \ldots, b_t\}$.
For each $a_i \in A$ and $b_j \in B$ we have $i \geq t+1 > t \geq j$, hence $i > j$, and therefore $b_j \in \NbhC{a_i}$.

The elements $b_1, \ldots, b_t$ are pairwise distinct by the definition of a semi-ladder, so $|B| = t$.
The set $A$ has $2t$ elements.
For each $a_i \in A$ and $b_j \in B$ we have $b_j \in \NbhC{a_i}$.
The condition $b_j = a_i$ can hold for at most $|B| = t$ pairs $(a_i, b_j)$ with $a_i \in A$ and $b_j \in B$, since each element of $B$ can be equal to at most one element of~$A$ (the $b_j$ are pairwise distinct).

Therefore there exists a subset $A' \subseteq A$ of size $|A'| \geq |A| - t = t$ such that for every $a \in A'$ and every $b \in B$ we have $a \neq b$, and hence $b \in \NbhC{a}$ implies $\{a, b\} \in E$.
Choosing any $t$ elements from $A'$ yields a set that together with $B$ forms a $K_{t,t}$ subgraph, contradicting the assumption that $G$ contains no $K_{t,t}$.
\end{proof}

\begin{lemma}[Disjunction of permuted relations {\cite[Lemma~5]{FabianskiPST19}}]\label{lem:permutation-disjunction}
Let $\rho(\bar{x}; y)$ be a relation with semi-ladder index smaller than~$\ell$ for some $\ell \geq 1$, where $\bar{x}=(x_1,\ldots,x_k)$ and $k \geq 2$.
For a permutation $\pi$ of $\{1,\ldots,k\}$ let $\rho^{\pi}(\bar{x}; y)$ be the relation obtained from~$\rho$ by permuting the variables in~$\bar{x}$ according to~$\pi$.
Then for any permutations $\pi_1,\ldots,\pi_k$ the relation $\bigvee_{i=1}^{k}\rho^{\pi_i}(\bar{x}; y)$ has semi-ladder index smaller than $k^{\ell-1}$.
\end{lemma}

\begin{remark}
Lemma~\ref{lem:permutation-disjunction} is proved in~\cite[Lemma~5]{FabianskiPST19}; we use it as stated to avoid duplicating its proof.
Intuitively, if the disjunction admitted a semi-ladder of order $k^{\ell-1}$, then by repeatedly applying the pigeonhole principle one could extract a semi-ladder of order $\ell$ for one fixed disjunct $\rho^{\pi_i}$, contradicting the assumed semi-ladder index bound for~$\rho$.
\end{remark}

\begin{lemma}[Index bound for disjunctions]\label{lem:disjunction}
Let $\varphi(x; y)$ be a binary relation with semi-ladder index smaller than~$\ell$ for some $\ell \geq 1$.
Let $\psi(x_1, \ldots, x_k; y) := \bigvee_{i=1}^k \varphi(x_i, y)$ for $k \geq 2$.
Then the semi-ladder index of~$\psi$ is smaller than $k^{\ell}$.
\end{lemma}

\begin{proof}
Consider the relation
$\varphi'(x_1, \ldots, x_k; y) := \varphi(x_1, y)$, which ignores the variables $x_2, \ldots, x_k$.
Any semi-ladder for $\varphi'$ projects (by forgetting $x_2,\ldots,x_k$) to a semi-ladder of the same order for~$\varphi$, and conversely any semi-ladder for~$\varphi$ induces a semi-ladder for~$\varphi'$ by extending each left vertex with arbitrary values in the dummy coordinates.
Hence $\varphi'$ has semi-ladder index smaller than~$\ell$.

For each permutation $\pi$ of $\{1, \ldots, k\}$ let $\varphi'^{\pi}$ be the relation obtained from~$\varphi'$ by permuting the variables $x_1, \ldots, x_k$ according to~$\pi$.
For the permutation $\pi_i$ with $\pi_i(1)=i$ we have $\varphi'^{\pi_i}(x_1, \ldots, x_k; y) = \varphi(x_i, y)$, and therefore
\[
\psi(x_1, \ldots, x_k; y) = \bigvee_{i=1}^k \varphi'^{\pi_i}(x_1, \ldots, x_k; y).
\]

By Lemma~\ref{lem:permutation-disjunction}, the semi-ladder index of this disjunction is smaller than $k^{\ell-1}$, and hence also smaller than $k^\ell$ (since $k\ge 2$ and $\ell\ge 1$).
\end{proof}

\begin{theorem}[Semi-ladder index bound]\label{thm:sd-bound}
If $G$ is $d$-degenerate, then the semi-ladder index of $H_G$ is smaller than $p(d,k)$.
\end{theorem}

\begin{proof}
By Lemma~\ref{lem:biclique}, the graph $G$ contains no $K_{t,t}$ for $t := d+1$.
By Lemma~\ref{lem:delta1-semiladder}, the semi-ladder index of the relation $\delta_1(x,y) := (y \in \NbhC{x})$ is smaller than $\ell := 3t = 3(d+1) = 3d + 3$.

The graph $H_G$ corresponds to the relation $\psi(\bar{x}; y) := \bigvee_{i=1}^k \delta_1(x_i, y)$, where for $k=0$ we interpret the disjunction as identically false.
If $k \le 1$, then $\psi(\bar{x};y)$ is either false (for $k=0$) or equals $\delta_1(x_1,y)$ (for $k=1$), and in both cases its semi-ladder index is smaller than $\max(1,\ell)\le 2^{\ell}=p(d,k)$.
If $k \ge 2$, then by Lemma~\ref{lem:disjunction} the semi-ladder index of~$\psi$ is smaller than $k^{\ell} \le \max(2,k)^{\ell}=p(d,k)$.
\end{proof}


% ============================================================================
\subsection{Candidate oracle}\label{sec:candidate}
% ============================================================================

The candidate oracle takes a set of witnesses $W \subseteq V$ and should return a set $D \subseteq V$ with $|D| \leq k$ that dominates~$W$, or report that no such set exists.

\subsubsection[Computing the set U(X)]{Computing the set \texorpdfstring{$U(X)$}{U(X)}}

For a set $X \subseteq V$ we define $U(X) := \{u \in V \setminus X : X \subseteq \Nbh(u)\}$ as the set of vertices outside~$X$ whose open neighborhood contains all of~$X$.

\begin{lemma}[Decomposition of $U(X)$]\label{lem:U-decomp}
For a nonempty $X \subseteq V$ we define $U_2(X) := \{u \in U(X) : X \subseteq \Np(u)\}$, $U_1(X) := U(X) \setminus U_2(X)$, and $C(X) := \bigcup_{x \in X} \Np(x)$.
Then $U(X) = U_1(X) \cup U_2(X)$ (disjoint union) and $U_1(X) \subseteq C(X)$.
\end{lemma}

\begin{proof}
The decomposition $U(X) = U_1(X) \cup U_2(X)$ follows from the definitions.
Let $u \in U_1(X)$.
By the definition of $U(X)$, we have $X \subseteq \Nbh(u)$, i.e., every $x \in X$ is a neighbor of $u$ in the undirected graph.
By the definition of $U_1(X)$, we have $X \not\subseteq \Np(u)$, so there exists $x \in X$ such that $x \notin \Np(u)$.
Since $x \in X \subseteq \Nbh(u)$, the edge $\{u, x\}$ exists in the graph.
As $x \notin \Np(u)$, this edge is oriented as $(x, u)$, hence $u \in \Np(x) \subseteq C(X)$.
\end{proof}

Note that for every nonempty $X$ we have $U_2(X) \subseteq B(X)$.
Indeed, if $u \in U_2(X)$ then $X \subseteq \Np(u)$, which means $u \in B(X)$.
Conversely, if $u \in B(X)$ then $X \subseteq \Np(u) \subseteq \Nbh(u)$.
Since $X$ is nonempty, this implies that $u$ has a neighbor in~$X$ and therefore $u \in V^+$.
Moreover, $u \notin X$, because otherwise we would have $u \in \Np(u)$, which is impossible in a simple loopless graph.
Thus $u \in U(X)$ and hence $u \in U_2(X)$.
Therefore, for every nonempty $X$ with $|X| \leq \Delta$ we have $U_2(X) = B(X)$.
For $|X| > \Delta$ we have $U_2(X) = \emptyset$, since $|\Np(u)| \leq \Delta$ for every~$u$.

\begin{lemma}[Complexity of computing $U(X)$]\label{lem:U-time}
For a nonempty set $X$ with $|X| \leq t$, in time $O(\Delta \cdot t^2 \cdot (\log n + \Delta))$ one can compute the list of elements of $U_1(X)$ and its size, as well as (if $|X| \leq \Delta$) a reference to the bucket $B(X)$ representing $U_2(X)$ together with its size.
An explicit list of elements of $U_2(X)$ is not generated, as its size can be linear.
\end{lemma}

\begin{proof}
We compute $U_1(X)$ by enumerating the multiset union $\bigcup_{x \in X}\Np(x)$ and de-duplicating on the fly.
We traverse all pairs $(x,u)$ with $x \in X$ and $u \in \Np(x)$; there are at most $\Delta \cdot |X|$ such pairs.
We maintain a global array indexed by $V$ storing timestamps, together with a global counter.
At the beginning of the computation of $U_1(X)$ we increment the counter and treat a vertex as unmarked if its timestamp differs from the current counter value; marking the vertex consists of writing the current counter value into its timestamp cell.
Thus, no entry of the array is ever reset, and each encountered vertex $u$ is processed at most once.
Whenever we encounter a previously unmarked vertex $u$, we mark it and check whether $X \subseteq \Nbh(u)$.
This check requires $|X|$ membership queries in the neighbor dictionaries, each taking time $O(\log n)$.
If the check succeeds, we append $u$ to the output list; the list length is the computed value $|U_1(X)|$.
Finally, since $u \in \Np(x)$ for some $x \in X$, we have $x \notin \Np(u)$ and therefore $X \not\subseteq \Np(u)$, implying $u \notin U_2(X)$.
Hence every appended vertex indeed belongs to $U_1(X)$.
The total cost of this phase is $O(\Delta \cdot |X| \cdot |X| \cdot \log n) = O(\Delta \cdot t^2 \cdot \log n)$.

We compute $U_2(X)$ as follows.
If $|X| > \Delta$, then $U_2(X) = \emptyset$.
If $|X| \leq \Delta$, then $U_2(X) = B(X)$, which we read from the bucket dictionary in time $O(\Delta(\log n + \Delta))$ together with its size counter.
The total cost is $O(\Delta \cdot t^2 \cdot \log n + \Delta(\log n + \Delta)) = O(\Delta \cdot t^2 \cdot (\log n + \Delta))$.
\end{proof}

\subsubsection{Candidate oracle algorithm}

The candidate oracle works as follows.
For each nonempty $S \subseteq W$ we compute a \emph{representative}, that is, a vertex $\mathrm{rep}(S)$ that dominates~$S$ (if one exists).
We test vertices $v \in S$ and if some $v$ satisfies $S \setminus \{v\} \subseteq \Nbh(v)$, we set $\mathrm{rep}(S) := v$.
Otherwise we use Lemma~\ref{lem:U-time}: we compute $U_1(S)$ and check whether $U_2(S)$ is nonempty (represented by the bucket $B(S)$ for $|S| \leq \Delta$).
If $U_1(S) \neq \emptyset$, we set $\mathrm{rep}(S)$ to the first element of the computed list $U_1(S)$.
Otherwise, if $U_2(S) \neq \emptyset$, we set $\mathrm{rep}(S)$ to the first element of the bucket list for $B(S)$.
If both sets are empty, then no representative of $S$ exists.

Next we compute values $\mathrm{dp}(A)$ for all $A \subseteq W$ using dynamic programming.
We define $\mathrm{dp}(\emptyset) := 0$ and
\[
\mathrm{dp}(A) := 1 + \min \{\mathrm{dp}(A \setminus S) : \emptyset \neq S \subseteq A,\ \text{a representative of } S \text{ exists}\}
\]
with the convention that the minimum over the empty set equals $+\infty$.
If $\mathrm{dp}(W) \leq k$, we reconstruct a dominating set by backtracking the optimal choices.

\begin{theorem}[Correctness of the candidate oracle]\label{thm:candidate-correct}
The candidate oracle is correct: it returns a set $D$ that dominates $W$ with $|D| \leq k$ if one exists, and reports that no solution exists otherwise.
\end{theorem}

\begin{proof}
If the oracle returns a set~$D$, it does so by backtracking the table $\mathrm{dp}$.
Starting with $A:=W$ and $D:=\emptyset$, it repeatedly chooses a nonempty set $S \subseteq A$ such that a representative of~$S$ exists and $\mathrm{dp}(A)=1+\mathrm{dp}(A \setminus S)$, adds $\mathrm{rep}(S)$ to~$D$, and replaces $A$ with $A \setminus S$.
This produces sets $S_1,\ldots,S_r$ that are pairwise disjoint and form a partition of~$W$, where $r=|D|=\mathrm{dp}(W)\le k$.
Each representative $\mathrm{rep}(S_i)$ dominates its set $S_i$, hence $D$ dominates~$W$.

Now suppose there exists a set $D^*$ that dominates~$W$ with $|D^*| \leq k$.
For each $w \in W$ we choose any $f(w) \in D^*$ such that $w \in \NbhC{f(w)}$ (such a vertex exists since $D^*$ dominates~$W$; if $w$ has multiple neighbors in $D^*$, we choose one deterministically, e.g., the one with the smallest identifier).
The sets $S_v := f^{-1}(v)$ for $v \in D^*$ form a partition of~$W$.
For a nonempty $S_v$: if $v \in S_v$, then $v$ dominates $S_v$ and $S_v \setminus \{v\} \subseteq \Nbh(v)$, so $v$ is a representative of~$S_v$; if $v \notin S_v$, then $S_v \subseteq \Nbh(v)$, so $v \in U(S_v)$ and a representative of $S_v$ exists.
In both cases a representative of $S_v$ exists, hence $\mathrm{dp}(W) \leq |D^*| \leq k$.
\end{proof}

\begin{theorem}[Complexity of the candidate oracle]\label{thm:candidate-time}
For $|W| \leq t$, the candidate oracle runs in time $O(3^t \cdot \Delta \cdot t^2 \cdot (\log n + \Delta))$.
\end{theorem}

\begin{proof}
Computing a representative for a single $S \subseteq W$ requires checking at most $|S|$ internal candidates (each test: $|S| - 1$ neighborhood checks, cost $O(t \cdot \log n)$ per candidate, total $O(t^2 \cdot \log n)$), and if that fails, computing $U(S)$ (cost $O(\Delta \cdot t^2 \cdot (\log n + \Delta))$ by Lemma~\ref{lem:U-time}).
The number of nonempty subsets of $W$ is $2^t - 1$.
The total cost of computing all representatives is $O(2^t \cdot \Delta \cdot t^2 \cdot (\log n + \Delta))$.

Computing the table~$\mathrm{dp}$: for each $A \subseteq W$ we consider all nonempty $S \subseteq A$.
The number of pairs $(A, S)$ with $\emptyset \neq S \subseteq A \subseteq W$ equals $\sum_{a=0}^t \binom{t}{a} (2^a - 1) = 3^t - 2^t$.
The cost is $O(3^t)$.
Since $2^t \le 3^t$ and $\Delta \cdot t^2 \cdot (\log n + \Delta) \ge 1$, we obtain
\[
O(2^t \cdot \Delta \cdot t^2 \cdot (\log n + \Delta)) + O(3^t) = O(3^t \cdot \Delta \cdot t^2 \cdot (\log n + \Delta)).
\]
\end{proof}


% ============================================================================
\subsection{Witness oracle}\label{sec:witness}
% ============================================================================

The witness oracle takes a set $D \subseteq V$ with $|D| \leq k$ and should return a vertex not dominated by~$D$, or report that $D$ is a dominating set.

\subsubsection{Overview}

For $D \subseteq V$ we denote $\Dom(D) := \bigcup_{v \in D} \NbhC{v}$.
\begin{lemma}[Finding an isolated witness]\label{lem:isolated-witness}
Given a set $D \subseteq V$ with $|D|\le k$, in time $O(k \log n)$ one can either find an isolated vertex $r \in V \setminus V^+$ with $r \notin D$, or correctly conclude that $V \setminus V^+ \subseteq D$.
\end{lemma}

\begin{proof}
We store the set $D$ in a dictionary (implemented as a balanced binary search tree) to support membership queries in time $O(\log n)$.
Using the interval representation of $V\setminus V^+$, we obtain the smallest isolated vertex $r_0$ in time $O(\log n)$; if no isolated vertex exists, we are done.
For $t=0,1,\ldots,k$ we do the following: if $r_t \notin D$ we return $r_t$; otherwise, we compute the next isolated vertex $r_{t+1}$ after $r_t$ in time $O(\log n)$.
If no such vertex exists, then we have enumerated all isolated vertices and hence $V\setminus V^+ \subseteq D$.
If the loop performed $k+1$ iterations without returning a vertex and without exhausting the isolated vertices, then it would have found $k+1$ distinct isolated vertices contained in~$D$, contradicting $|D|\le k$.
Thus the procedure is correct and runs in time $O(k\log n)$.
\end{proof}

We first handle isolated vertices using Lemma~\ref{lem:isolated-witness}.
If it returns a vertex $r \in V \setminus V^+$ with $r \notin D$, then $r \notin \Dom(D)$ (since $\NbhC{r}=\{r\}$), and we return such~$r$ as a witness.
Otherwise, all isolated vertices belong to~$D$ and hence are dominated, and it suffices to consider the set
\[
R := V^+ \setminus \Dom(D).
\]
If $R = \emptyset$, we report that $D$ dominates the whole graph; otherwise we proceed to recover some element $r \in R$ using the isolation mechanism described below.

The witness oracle computes $|R|$ and, for each pair $(i,j)$, the values $|R \cap S_{i,j}|$ and $\idsum(R \cap S_{i,j})$ using Lemma~\ref{lem:inclusion-exclusion} for the family $\{\NbhC{v} : v \in D\}$ restricted to the set $V^+$.
For a set $X \subseteq V$ we define $I(X) := \bigcap_{v \in X} \NbhC{v}$.
We also denote $I^+(X) := I(X) \cap V^+$.

\begin{lemma}[Inclusion--exclusion]\label{lem:inclusion-exclusion}
Let $U$ be a finite set and let $\{A_v\}_{v \in D}$ be a family of subsets of~$U$ indexed by a finite set~$D$.
Then
\[
\left|\bigcup_{v \in D} A_v\right|
=
\sum_{\emptyset \neq X \subseteq D} (-1)^{|X|+1} \left|\bigcap_{v \in X} A_v\right|.
\]
Moreover, for every fixed $U' \subseteq U$ the same identity holds after intersecting all sets with~$U'$.
\end{lemma}

\begin{proof}
For $u \in U$ let $\mathbf{1}_{u \in A_v}$ be the indicator of membership of~$u$ in~$A_v$.
Then the indicator of the event $u \in \bigcup_{v \in D} A_v$ equals $1-\prod_{v \in D} (1-\mathbf{1}_{u \in A_v})$.
Expanding the product yields
$
\mathbf{1}_{u \in \cup_{v \in D} A_v}
=
\sum_{\emptyset \neq X \subseteq D} (-1)^{|X|+1}\prod_{v \in X}\mathbf{1}_{u \in A_v}.
$
Summing over $u \in U$ gives the stated identity.
Intersecting all sets with a fixed $U'$ amounts to restricting the summation domain from $U$ to~$U'$.
\end{proof}

\begin{lemma}[Decomposition of $I(X)$]\label{lem:I}
For nonempty $X$ we have $I(X) = U(X) \cup X'$, where $X' := \{x \in X : X \setminus \{x\} \subseteq \Nbh(x)\}$.
The sets $U(X)$ and $X'$ are disjoint.
\end{lemma}

\begin{proof}
Let $y \in I(X)$.
For each $v \in X$ we have $y \in \NbhC{v}$, that is, $y = v$ or $y \in \Nbh(v)$.
If $y \notin X$, then for each $v \in X$ we have $y \in \Nbh(v)$, hence $X \subseteq \Nbh(y)$ and $y \in U(X)$.
If $y \in X$, then for $v \in X \setminus \{y\}$ we have $y \in \NbhC{v}$, and since $y \neq v$ this implies $y \in \Nbh(v)$, so $X \setminus \{y\} \subseteq \Nbh(y)$ and therefore $y \in X'$.
The sets $U(X)$ and $X'$ are disjoint because $U(X) \cap X = \emptyset$ by definition.

Conversely, if $y \in U(X)$ then $X \subseteq \Nbh(y)$, so for each $v \in X$ we have $y \in \Nbh(v) \subseteq \NbhC{v}$, hence $y \in I(X)$.
If $y \in X'$, then $y \in X$ and $X \setminus \{y\} \subseteq \Nbh(y)$.
For $v = y$ we have $y \in \NbhC{y}$.
For $v \in X \setminus \{y\}$ we have $v \in \Nbh(y)$, hence $y \in \Nbh(v) \subseteq \NbhC{v}$.
Therefore $y \in I(X)$.
\end{proof}

By Lemma~\ref{lem:inclusion-exclusion} applied to the sets $\NbhC{v} \cap V^+$ for $v \in D$:
\[
|R| = |V^+| - |\Dom(D) \cap V^+| = |V^+| - \sum_{\emptyset \neq X \subseteq D} (-1)^{|X|+1} |I^+(X)|
= |V^+| + \sum_{\emptyset \neq X \subseteq D} (-1)^{|X|} |I^+(X)|.
\]

\begin{lemma}[Computing the sets $I^+(X)$]\label{lem:Iplus-compute}
Let $X \subseteq V$ be nonempty.
Then $U(X) \subseteq V^+$ and therefore $I^+(X) = U(X) \cup (X' \cap V^+)$, where $X'$ is defined in Lemma~\ref{lem:I}.
Moreover, for every pair $(i,j)$ we have
\[
|I^+(X)\cap S_{i,j}| = |U(X)\cap S_{i,j}| + |X' \cap V^+ \cap S_{i,j}|.
\]
\end{lemma}

\begin{proof}
Let $u \in U(X)$.
Since $X$ is nonempty, choose any $x \in X$.
By the definition of $U(X)$ we have $x \in \Nbh(u)$, so $\deg(u) \ge 1$ and hence $u \in V^+$.
Thus $U(X)\subseteq V^+$.

By Lemma~\ref{lem:I} we have a disjoint union $I(X)=U(X)\cup X'$.
Intersecting this identity with~$V^+$ and using $U(X)\subseteq V^+$ yields $I^+(X)=U(X)\cup (X'\cap V^+)$, still a disjoint union.
Intersecting further with $S_{i,j}$ gives $I^+(X)\cap S_{i,j} = (U(X)\cap S_{i,j}) \cup (X'\cap V^+\cap S_{i,j})$, again disjoint, hence the cardinality formula.
\end{proof}

\begin{lemma}[Computing the inclusion--exclusion terms]\label{lem:iex-terms}
Let $X \subseteq V$ be nonempty and let $X'$ be defined as in Lemma~\ref{lem:I}.
Suppose we computed the explicit list of~$U_1(X)$ and its size, and obtained (if $|X|\le \Delta$) a reference to the bucket $B(X)$ together with its size, as guaranteed by Lemma~\ref{lem:U-time}.
Then
\[
|I^+(X)| = |U_1(X)| + |U_2(X)| + |X' \cap V^+|,
\]
where $U_2(X)=B(X)$ if $|X|\le \Delta$ and $U_2(X)=\emptyset$ otherwise.
Moreover, for every pair $(i,j)$ we have
\[
|I^+(X)\cap S_{i,j}| = |U_1(X)\cap S_{i,j}| + |U_2(X)\cap S_{i,j}| + |X' \cap V^+ \cap S_{i,j}|,
\]
and
\[
\begin{aligned}
\idsum(I^+(X)\cap S_{i,j})
&\equiv
\idsum(U_1(X)\cap S_{i,j}) + \idsum(U_2(X)\cap S_{i,j}) \\
&\qquad + \idsum(X' \cap V^+ \cap S_{i,j})
\pmod{2^w}.
\end{aligned}
\]
If $|X|\le \Delta$ and the bucket $B(X)$ exists, then $|U_2(X)\cap S_{i,j}|$ and $\idsum(U_2(X)\cap S_{i,j})$ are given by the stored counters $C_{X,i,j}$ and $T_{X,i,j}$; if $B(X)$ is empty (and hence not stored), these values are $0$.
\end{lemma}

\begin{proof}
By Lemma~\ref{lem:Iplus-compute} we have $I^+(X)=U(X)\cup (X'\cap V^+)$ as a disjoint union.
By Lemma~\ref{lem:U-decomp}, we have a disjoint union $U(X)=U_1(X)\cup U_2(X)$.
Combining the two disjoint unions yields $I^+(X)=U_1(X)\cup U_2(X)\cup (X'\cap V^+)$, hence the first cardinality identity.

Intersecting this disjoint union with~$S_{i,j}$ yields the cardinality identity for $|I^+(X)\cap S_{i,j}|$.
The identity for $\idsum$ follows analogously, since $\idsum(\cdot)$ is computed modulo~$2^w$ and therefore is additive over disjoint unions.
Finally, if $|X|\le \Delta$ then $U_2(X)=B(X)$ and the stored counters satisfy $C_{X,i,j}=|B(X)\cap S_{i,j}|$ and $T_{X,i,j}=\idsum(B(X)\cap S_{i,j})$ by definition.
\end{proof}

\subsubsection{Element isolation}

If $|R| = 0$, we report domination.
If $|R| > 0$, we try to \emph{isolate} a single element $r \in R$ using the sets $S_{i,j}$.
For each pair $(i,j)$ we compute $|R \cap S_{i,j}|$ and $\idsum(R \cap S_{i,j})$ using the analogous inclusion--exclusion formula over $V^+$, in which the term for $X=\emptyset$ is given by the global counters $C_{\mathrm{all},i,j}$ and $T_{\mathrm{all},i,j}$.
If $|R \cap S_{i,j}| = 1$ and $r$ is the unique element of $R \cap S_{i,j}$, then $\idsum(R \cap S_{i,j}) = \id(r) \bmod 2^w = \id(r)$, because $\id(r) < n < 2^w$.
After verification (checking that the recovered vertex $r$ satisfies $r \in V^+$ and $r \notin \Dom(D)$) we return~$r$.

If for no pair $(i,j)$ we have $|R \cap S_{i,j}| = 1$, we perform \emph{resampling}: we sample a new seed $\sigma'$ (hence independently new functions $h_1, \ldots, h_\lambda$), recompute all counters $C_{Z,i,j}, T_{Z,i,j}$ in nonempty buckets and the global counters $C_{\mathrm{all},i,j}, T_{\mathrm{all},i,j}$ for $V^+$, and repeat the isolation procedure.

\begin{lemma}[Isolation]\label{lem:isolation}
If $|R| = s \geq 1$, then there exists $i \in \{0, \ldots, 2w-1\}$ such that $\Pr(|R \cap S_{i,j}| = 1) \geq 1/(2e)$ for every~$j$.
\end{lemma}

\begin{proof}
Let $s := |R| \geq 1$ and $p_i = 2^{-i-1}$.
We choose $i^* := \lfloor \log_2 s \rfloor + 1$.
Since $s \leq n < 2^w$, we have $i^* \leq w \leq 2w-1$, hence $i^* \in \{0, \ldots, 2w-1\}$.

Fix $j$ and let $X = |R \cap S_{i^*,j}|$.
Let $I_v$ be the indicator random variable of the event $v \in S_{i^*,j}$.
Then $X = \sum_{v \in R} I_v$ and $\Pr(I_v = 1) = p_{i^*}$ for each $v \in R$.
Pairwise independence of the hash family also implies that for distinct $u, v \in R$ we have $\Pr(I_u = 1 \land I_v = 1) = p_{i^*}^2$.

We lower bound $\Pr(X = 1)$.
Since the events
$I_v = 1 \land \bigwedge_{u \in R \setminus \{v\}} I_u = 0$ (for $v \in R$) are pairwise disjoint, we have:
\begin{align*}
\Pr(X = 1)
&= \sum_{v \in R} \Pr\bigl(I_v = 1 \land \bigwedge_{u \in R \setminus \{v\}} I_u = 0\bigr) \\
&= \sum_{v \in R} \Bigl( \Pr(I_v = 1) - \Pr(I_v = 1 \land \exists_{u \in R \setminus \{v\}} I_u = 1) \Bigr) \\
&\geq \sum_{v \in R} \Bigl( p_{i^*} - \sum_{u \in R \setminus \{v\}} \Pr(I_v = 1 \land I_u = 1) \Bigr) \\
&= s \cdot p_{i^*} - s(s-1) p_{i^*}^2.
\end{align*}

Let $\mu := s \cdot p_{i^*}$.
From the definition $i^* = \lfloor \log_2 s \rfloor + 1$ we have $2^{i^*-1} \le s < 2^{i^*}$, so $\mu \in [1/4, 1/2)$.
Let $g(\mu):=\mu-\mu^2$.
Since $g'(\mu)=1-2\mu \ge 0$ for $\mu \in (0,1/2]$, the function $g$ is increasing on this interval, and hence $g(\mu) \ge g(1/4)=3/16$.
Moreover, $e = \sum_{t=0}^{\infty} 1/t! > 1 + 1 + 1/2 + 1/6 = 8/3$, so $1/(2e) < 3/16$.
Therefore
\[
\Pr(X = 1) \geq \mu - \mu^2 \ge 3/16 > 1/(2e).
\]
\end{proof}

\begin{theorem}[Witness oracle]\label{thm:domwitness}
The witness oracle is correct and has expected running time $O((2^k \cdot (1+\Delta)^2 \cdot k^3 + d \cdot 2^\Delta)\cdot \log^3 n)$.
\end{theorem}

\begin{proof}
\textit{Correctness:}
If there exists an isolated vertex $r \in V \setminus V^+$ such that $r \notin D$, the procedure returns a correct witness (such $r$ is not dominated by~$D$).
Otherwise, all isolated vertices belong to~$D$ and hence are dominated, and it suffices to consider $R = V^+ \setminus \Dom(D)$.
Computing $|R|$ by inclusion--exclusion (restricted to $V^+$) is deterministic and correct.
Isolation guarantees recovering an element of~$R$, which is verified before being returned.
Resampling is performed until success, so the procedure always returns a correct result (Las~Vegas).

\textit{Cost of a single try:}
We first invoke Lemma~\ref{lem:isolated-witness}, which costs $O(k\log n)$ time and either terminates with an isolated witness or establishes that all isolated vertices belong to~$D$.
For each nonempty $X \subseteq D$ (there are $2^k - 1$ of them) we compute $U(X)$ via Lemma~\ref{lem:U-time} and we compute $X'$ as in Lemma~\ref{lem:I}; this takes $O(\Delta \cdot k^2 \cdot (\log n + \Delta))$ time per~$X$.
By Lemma~\ref{lem:iex-terms}, these values determine $|I^+(X)|$ as well as, for every pair $(i,j)$, the quantities $|I^+(X)\cap S_{i,j}|$ and $\idsum(I^+(X)\cap S_{i,j})$ needed to update the inclusion--exclusion accumulators for $|R|$, $|R\cap S_{i,j}|$, and $\idsum(R\cap S_{i,j})$.
The accumulators for the cardinalities are maintained as signed multiword integers (Lemma~\ref{lem:multiword}), which incurs an additional factor $O(k+1)$ per update of an inclusion--exclusion sum.
If the isolation step succeeds, we additionally verify the recovered vertex $r$ by testing $r \in V^+$ and $r \notin \Dom(D)$, which takes $O(k \cdot \log n)$ time and is dominated by the previous terms.
The total cost of one try is $T_{\mathrm{try}} = O(2^k \cdot (1+\Delta) \cdot k^3 \cdot (\log n + \Delta) \cdot \log^2 n)$.

\textit{Success probability:}
Assume $|R|\ge 1$.
Let $q$ denote the probability (over the random seed~$\sigma$) that the isolation step fails in a single try, i.e., for every $j\in\{1,\ldots,\lambda\}$ and every $i\in\{0,1,\ldots,2w-1\}$ we have $|R\cap S_{i,j}|\neq 1$.
By Lemma~\ref{lem:isolation}, there exists $i^*$ such that for each fixed $j$ the event $|R\cap S_{i^*,j}|=1$ has probability at least $1/(2e)$.
Moreover, since the functions $h_1,\ldots,h_\lambda$ are sampled independently, the events $|R\cap S_{i^*,j}|=1$ are independent over distinct values of~$j$.
Therefore, $q \le (1 - 1/(2e))^\lambda \leq e^{-\lambda/(2e)}$.
Since $\lambda = \lceil c_0 \log n \rceil \ge c_0 \log n$, we obtain $q \le e^{-c_0\log n/(2e)}$.
If $n\ge 2$ then $\log n=\log_2 n$ and therefore $q \le n^{-c_0/(2e\ln 2)}$.
We have $e=\sum_{t\ge 0}1/t!\le 1+1+\sum_{t\ge 2}2^{-(t-1)}=3$ and $\ln 2<1$, hence $2e\ln 2 < 6$ and $c_0/(2e\ln 2)>7/6>1$.
Thus $q < n^{-1}$ for $n\ge 2$; for $n=1$ we have $q<1=n^{-1}$ as well.

\textit{Resampling cost:}
Resampling keeps the buckets and their element lists unchanged (they depend only on the current graph and its maintained orientation), and only recomputes the counters for the new seed~$\sigma'$.
We traverse the global list of nonempty buckets and reset their $O(\log^2 n)$ counters to~$0$.
Since each nonempty bucket contributes at least one registration record, the number of nonempty buckets is at most the number of records and this work is subsumed by the subsequent traversal.
Next, we traverse all registration records by iterating over all vertices of~$V^+$ and their registration lists; each record corresponds to an incidence $(u,Z)$ with $u \in B(Z)$.
There are at most $|V^+|\cdot 2^\Delta \leq 2m \cdot 2^\Delta$ such records.
For each record we update the $O(\log^2 n)$ counters for the bucket by testing membership of~$u$ in all $S_{i,j}$ and adding $\id(u)$ to the corresponding identifier sums.
Thus recomputing all bucket counters takes $O(m \cdot 2^\Delta \cdot \log^2 n)$ time.
Recomputing the global counters for $V^+$ takes $O(|V^+|\cdot \log^2 n)=O(m \cdot \log^2 n)$ time, which is dominated by $O(m \cdot 2^\Delta \cdot \log^2 n)$ since $2^\Delta\ge 1$.
Hence the cost of one resampling is $T_{\mathrm{res}} = O(m \cdot 2^\Delta \cdot \log^2 n)$.

\textit{Expected number of tries:}
During a single invocation of the witness oracle, the graph state (and hence the sets $V^+$ and the bucket system) and the input set~$D$ remain fixed.
Each resampling draws an independent seed and the computation within one try is deterministic given the seed, the fixed graph state, and the fixed set~$D$.
Therefore, the number of tries has a geometric distribution with success probability exactly $1-q$.
Hence $\mathbb{E}[\#\text{tries}] = (1-q)^{-1}$ and $\mathbb{E}[\#\text{resamplings}] = q(1-q)^{-1}$.
Using $q<n^{-1}$ we obtain $\mathbb{E}[\#\text{tries}] \le (1-n^{-1})^{-1}$ and $\mathbb{E}[\#\text{resamplings}] \le n^{-1}(1-n^{-1})^{-1}$.

\textit{Expected cost:}
\begin{align*}
\mathbb{E}[\text{cost}] &\leq T_{\mathrm{try}} \cdot \mathbb{E}[\#\text{tries}] + T_{\mathrm{res}} \cdot \mathbb{E}[\#\text{resamplings}] \\
&= O(T_{\mathrm{try}}) + O(T_{\mathrm{res}} / n) \\
&= O(T_{\mathrm{try}}) + O((m/n) \cdot 2^\Delta \cdot \log^2 n) \\
&= O(T_{\mathrm{try}}) + O(d \cdot 2^\Delta \cdot \log^2 n) \qquad\text{(by Corollary~\ref{cor:edge-bound})} \\
&= O(2^k \cdot (1+\Delta) \cdot k^3 \cdot (\log n + \Delta) \cdot \log^2 n) + O(d \cdot 2^\Delta \cdot \log^2 n) \\
&= O\!\left((2^k \cdot (1+\Delta)^2 \cdot k^3 + d \cdot 2^\Delta)\cdot \log^3 n\right).
\end{align*}
\end{proof}


% ============================================================================
\subsection{Main loop}\label{sec:query-loop}
% ============================================================================

The main loop constructs sequences of witness sets $W_0,W_1,\ldots$ and candidate sets $D_0,D_1,\ldots$.
It starts with $W_0:=\emptyset$.
For $t=0,1,2,\ldots$, it invokes the candidate oracle on~$W_t$.
If the oracle reports that no dominating set of $W_t$ of size at most~$k$ exists, the procedure returns~$\bot$.
Otherwise, it obtains a set $D_t$ with $|D_t|\le k$ that dominates~$W_t$ and invokes the witness oracle on~$D_t$.
If the witness oracle confirms that $D_t$ dominates~$V$, the procedure returns~$D_t$.
Otherwise it returns a vertex $r_t \notin \Dom(D_t)$ and the loop sets $W_{t+1}:=W_t\cup\{r_t\}$.

\begin{theorem}[Correctness and complexity of \proc{Query}]\label{thm:query}
The procedure \proc{Query} is correct and has expected running time $O(f(d,k)\cdot \log^3 n)$, where $f(d,k)$ is defined in Section~\ref{sec:intro}.
\end{theorem}

\begin{proof}
\textit{Correctness:}
This follows from the correctness of the oracles (Theorems~\ref{thm:candidate-correct} and~\ref{thm:domwitness}).
If the procedure returns a set~$D$, then the witness oracle confirmed that $D$ dominates the whole graph.
If the procedure returns $\bot$, then the candidate oracle reported that there is no dominating set of~$W$ of size $\leq k$, which implies that there is no dominating set of the entire graph of size $\leq k$.

\textit{Number of rounds:}
By Lemma~\ref{lem:sd-alg} and Theorem~\ref{thm:sd-bound}, the number of rounds is at most~$p(d,k)$.

\textit{Complexity:}
In each round we have $|W| \leq p(d,k)$.
The cost of the candidate oracle is $O(3^{p(d,k)} \cdot \Delta \cdot p(d,k)^2 \cdot (\log n + \Delta))$ (Theorem~\ref{thm:candidate-time}).
The expected cost of the witness oracle is $O((2^k \cdot (1+\Delta)^2 \cdot k^3 + d \cdot 2^\Delta)\cdot \log^3 n)$ (Theorem~\ref{thm:domwitness}).
The total expected time is
\[
p(d,k) \cdot \left(O(3^{p(d,k)} \cdot \Delta \cdot p(d,k)^2 \cdot (\log n + \Delta)) + O((2^k \cdot (1+\Delta)^2 \cdot k^3 + d \cdot 2^\Delta)\cdot \log^3 n)\right).
\]
Since $\log^3 n \ge \log n$ and $\log^3 n \ge 1$, we have $\Delta(\log n + \Delta) \le (1+\Delta)^2\log^3 n$.
Thus the displayed bound is $O(f(d,k)\cdot \log^3 n)$ by the definition of $f(d,k)$.
\end{proof}


% ============================================================================
\section{Proof of the main theorem}\label{sec:main-proof}
% ============================================================================

\begin{proof}[Proof of Theorem~\ref{thm:main}]
Correctness of \proc{Init} follows from Lemma~\ref{lem:init}.
Correctness of the update procedures follows from Lemma~\ref{lem:update-correct}.
Correctness of \proc{Query} follows from Theorem~\ref{thm:query}.

The initialization time follows from Lemma~\ref{lem:init}: $O(1)$.
 
The update time follows from Lemma~\ref{lem:update-time}: $O(2^{4d}\cdot (d^3+\log^3 n))$.
 
The query complexity follows from Theorem~\ref{thm:query}: $O(f(d,k)\cdot \log^3 n)$.
 
The space complexity follows from Theorem~\ref{thm:space}:
$O(n+m+m \cdot 2^\Delta \cdot \log^2 n) = O(n+m+m \cdot 2^{4d} \cdot \log^2 n)$.
Using Corollary~\ref{cor:edge-bound}, this is bounded by $O(n \cdot d \cdot 2^{4d} \cdot \log^2 n)$.
\end{proof}


% ============================================================================
\section{Conclusion}\label{sec:conclusion}
% ============================================================================

We presented a fully dynamic data structure for the dominating set problem on $d$-degenerate graphs with a fixed vertex set $V = \{1, \ldots, n\}$.
The structure achieves amortized update time $O(2^{4d}\cdot (d^3+\log^3 n))$ and expected query time $O(f(d,k) \cdot \log^3 n)$, where $f(d,k)$ is defined in Section~\ref{sec:intro}.
The main ingredients are the dynamic bounded-outdegree orientation of Brodal--Fagerberg, the bucket system indexed by subsets of out-neighborhoods, and the semi-ladder framework instantiated with a candidate oracle and a witness oracle.

\appendix

\section{Multiword integers}\label{app:multiword}

In the witness oracle we evaluate inclusion--exclusion sums over at most $2^k-1$ terms, each term being an integer between $0$ and~$n$.
Consequently, the absolute values of all intermediate sums are bounded by $2^k\cdot n$.
We use the following representation to support exact arithmetic on such numbers.

\begin{lemma}[Multiword integers]\label{lem:multiword}
Let $B := 2^w$.
Every integer $z$ with $|z| \le 2^k\cdot n$ can be represented in base~$B$ using $\ell=O(k+1)$ machine words.
Given two such representations, addition, subtraction, and comparison can be performed in time $O(\ell)=O(k+1)$.
\end{lemma}

\begin{proof}
Since $n < 2^w=B$, every $z$ with $|z| \le 2^k \cdot n$ satisfies $|z| < 2^k \cdot B < B^{k+1}$, and therefore admits a base-$B$ representation using at most $k+1$ digits, that is, $\ell \le k+1$ machine words.
Addition and subtraction can be implemented digit-by-digit with carries/borrows, and comparison can be implemented by checking the sign and then comparing the most significant differing digit.
Each operation scans $O(\ell)$ digits and therefore takes time $O(\ell)=O(k+1)$.
\end{proof}

\section{Interval representation of isolated vertices}\label{app:intervals}

Let $I := V \setminus V^+$.
We represent $I$ as a family of disjoint \emph{maximal} identifier intervals, that is, intervals $[a,b] \subseteq \{1,\ldots,n\}$ such that (i) $a,\ldots,b \in I$ and (ii) either $a=1$ or $a-1 \notin I$, and either $b=n$ or $b+1 \notin I$.
The family of maximal intervals is unique.
We store it as a dictionary keyed by the left endpoints $a$ (implemented as a balanced binary search tree).
Each node stores its endpoints $a,b$ and the length $b-a+1$; the structure also maintains $|I|$.

When a vertex $u$ becomes non-isolated, we remove it from~$I$ by locating the unique interval $[a,b]$ containing~$u$ and replacing it with up to two intervals $[a,u-1]$ and $[u+1,b]$ (discarding empty intervals).
When a vertex $u$ becomes isolated, we insert it into~$I$ by finding the predecessor and successor intervals (if any) and merging with those that are adjacent to~$u$ (i.e., ending at $u-1$ or starting at $u+1$), thereby maintaining maximality.
The smallest isolated identifier is the left endpoint of the first interval in the dictionary (if any), and the next isolated identifier after~$u$ is either $u+1$ (if $u \in I$ and $u$ is not the right endpoint of its interval) or the left endpoint of the successor interval (if it exists).

\begin{lemma}\label{lem:isolated-intervals}
The above representation of $I$ supports inserting and deleting one identifier, as well as reporting the minimum isolated identifier and the next isolated identifier after a given one, in time $O(\log n)$ per operation.
Moreover, at any time the number of stored intervals is at most $|V^+|+1$.
\end{lemma}

\begin{proof}
Correctness follows from maintaining the unique family of maximal intervals: deleting $u$ removes it from its unique containing interval and splits it if necessary, while inserting $u$ creates the singleton interval $[u,u]$ and merges with adjacent intervals to restore maximality.
All updates locate and modify only $O(1)$ intervals, hence take $O(\log n)$ dictionary operations.
To report the minimum or the next isolated identifier, we locate at most one containing interval and at most one successor interval, hence again $O(\log n)$ time.

For the interval bound, each stored interval is separated from the next one by at least one identifier not in~$I$, i.e., a vertex in~$V^+$.
Thus the number of intervals is at most $|V^+|+1$.
\end{proof}


\begin{thebibliography}{9}

\bibitem{BrodalFagerberg99}
G.~S.~Brodal and R.~Fagerberg.
\newblock Dynamic representations of sparse graphs.
\newblock In \emph{Proceedings of the 6th International Workshop on Algorithms and Data Structures (WADS 1999)}, volume 1663 of \emph{Lecture Notes in Computer Science}, pages 342--351. Springer, 1999.
\newblock doi:10.1007/3-540-48447-7\_34.

\bibitem{CarterWegman79}
J.~L.~Carter and M.~N.~Wegman.
\newblock Universal classes of hash functions.
\newblock \emph{Journal of Computer and System Sciences}, 18(2):143--154, 1979.
\newblock doi:10.1016/0022-0000(79)90044-8.

\bibitem{Dietzfelbinger96}
M.~Dietzfelbinger.
\newblock Universal hashing and $k$-wise independent random variables via integer arithmetic without primes.
\newblock In \emph{Proceedings of the 13th Annual Symposium on Theoretical Aspects of Computer Science (STACS 1996)}, volume 1046 of \emph{Lecture Notes in Computer Science}, pages 569--580. Springer, 1996.
\newblock doi:10.1007/3-540-60922-9\_46.

\bibitem{CLRS}
T.~H.~Cormen, C.~E.~Leiserson, R.~L.~Rivest, and C.~Stein.
\newblock \emph{Introduction to Algorithms}.
\newblock MIT Press, 3rd edition, 2009.

\bibitem{FabianskiPST19}
G.~Fabia\'nski, M.~Pilipczuk, S.~Siebertz, and S.~Toru\'nczyk.
\newblock Progressive algorithms for domination and independence.
\newblock In \emph{Proceedings of the 36th International Symposium on Theoretical Aspects of Computer Science (STACS 2019)}, volume 126 of Leibniz International Proceedings in Informatics (LIPIcs), pages 27:1--27:16. Schloss Dagstuhl -- Leibniz-Zentrum f\"ur Informatik, 2019.
\newblock doi:10.4230/LIPIcs.STACS.2019.27.

\bibitem{NashWilliams64}
C.~St.~J.~A.~Nash-Williams.
\newblock Decomposition of finite graphs into forests.
\newblock \emph{Journal of the London Mathematical Society}, s1-39(1):12--12, 1964.
\newblock doi:10.1112/jlms/s1-39.1.12.

\bibitem{NesetrilOssona12}
J.~Ne\v{s}et\v{r}il and P.~Ossona de Mendez.
\newblock \emph{Sparsity: Graphs, Structures, and Algorithms}.
\newblock Volume 28 of Algorithms and Combinatorics. Springer, 2012.
\newblock doi:10.1007/978-3-642-27875-4.

\end{thebibliography}

\end{document}
